import path from "node:path";
import type { TranslationService } from "../services/translation.ts";
import type { GitPlatform, GitWorkflow } from "../types.ts";
import type { Config } from "../utils/config.ts";
import { execAsync } from "../utils/exec.ts";
import { logger } from "../utils/logger.ts";

export class PullRequestWorkflow implements GitWorkflow {
  private readonly branchName: string;
  private hadTranslationChanges = false;

  constructor(
    private readonly gitProvider: GitPlatform,
    private readonly config: Config,
    private readonly translationService: TranslationService,
  ) {
    const { baseBranch } = this.gitProvider.getPlatformConfig();
    this.branchName = `languine/${baseBranch}`;
  }

  async preRun() {
    try {
      await this.#setupGit();
      logger.info("Successfully configured Git");
    } catch (error) {
      logger.error(error instanceof Error ? error.message : "Unknown error");
      throw new Error("Failed to configure Git");
    }

    // First ensure we're on the base branch and it's up to date
    const { baseBranch } = this.gitProvider.getPlatformConfig();
    logger.info(`Ensuring we're on base branch ${baseBranch}`);

    // Fetch and checkout base branch exactly like in branch flow
    await execAsync(`git fetch origin ${baseBranch}`);
    await execAsync(`git checkout ${baseBranch}`);
    await execAsync(`git reset --hard origin/${baseBranch}`);

    // Run translation detection on base branch first
    logger.info("Detecting translations on base branch");
    await this.translationService.runTranslation(this.config);

    // Now create our PR branch, preserving the detection state
    logger.info(`Creating PR branch ${this.branchName}`);
    await execAsync(`git checkout -b ${this.branchName}`);
  }

  async run() {
    logger.info("Running pull request workflow...");

    // Run translations again to apply changes
    await this.translationService.runTranslation(this.config);

    const hasChanges = await this.gitProvider.hasChanges();
    if (!hasChanges) {
      logger.info("No translation changes detected, skipping PR creation");
      this.hadTranslationChanges = false;
      return false;
    }

    logger.info("Changes detected, committing and pushing...");
    await this.gitProvider.addChanges();
    await this.gitProvider.commitAndPush({
      message: this.config.commitMessage,
      branch: this.branchName,
    });

    this.hadTranslationChanges = true;
    return true;
  }

  async postRun() {
    // Only create PR if we had changes in the run step
    if (!this.hadTranslationChanges) {
      logger.info("No translation changes to create PR for");
      return;
    }

    logger.info("Creating or updating pull request");
    await this.gitProvider.createOrUpdatePullRequest({
      title:
        this.config.prTitle ||
        "chore: (i18n) update translations using Languine.ai",
      body: this.#getPrBodyContent(),
      branch: this.branchName,
    });
  }

  async #setupGit() {
    await this.gitProvider.setupGit();

    const workingDir = path.resolve(
      process.cwd(),
      this.config?.workingDirectory,
    );

    if (workingDir !== process.cwd()) {
      logger.info(`Changing working directory to: ${workingDir}`);
      process.chdir(workingDir);
    }
  }

  #getPrBodyContent(): string {
    return `
🌐 Translation Updates

This PR contains automated translation updates from Languine.ai. The changes have been automatically generated and quality-checked.

### What Changed
- Updated translations to match latest source strings
- Maintained consistent terminology across languages
- Preserved existing translations where possible
- Applied quality checks and formatting

### Next Steps
1. Review the changes, focusing on key user-facing strings
2. Test the translations in context if possible
3. Approve and merge when ready

> Need help or have questions? Visit our [documentation](https://languine.ai/docs) or [contact support](https://languine.ai/support).

---
_Generated by [Languine](https://languine.ai) - Automated Translation Infrastructure_
    `.trim();
  }
}
